# Фронтенд Средиземья
*Обзор разработки под разные устройства*

* Три версии одного и того же сайта
* Управление состоянием
* Места съёмки
* Ресурсы
* Анимации
* Выводы

В [нашей первой статье][1] о разработке эксперимента для Google Chrome
[A Journey Through Middle-earth][2] мы сконцентрировались на работе с  WebGL
для мобильных устройств. В этой статье мы рассмотрим все задачи, проблемы и их
решения, к которым мы пришли в процессе работы над остальной частью фронтенда
на HTML5.


## Три версии одного и того же сайта

Давайте начнём с вопроса об адаптации этого сайта-эксперимента для работы и с
настольными компьютерами, и с мобильными устройствами с точки зрения изменения
размеров экрана и возможностей устройств.

Весь проект основан на «кинематографическом» стиле, где мы хотели побольше
использовать ландшафтную (горизонтальную) ориентацию экрана, чтобы сохранить
сходство с фильмом. Исходя из того, что большая часть сайта состоит из
мини-игр, то не имеет смысла, чтобы они тоже выходили за эти рамки.

Можно привести посадочную страницу сайта, как пример того, как мы адаптировали
дизайн для разных размеров экрана.

![][3]

*Орлы только что принесли нас на посадочную страницу.*

У сайта есть три разных режима: настольный, планшет и мобильный. Это не только
для того, что бы управлять версткой, но и для того, чтобы управлять временно
загружаемыми ресурсами и разнообразными способами оптимизации
производительности. Для устройств с разрешением экрана большим, чем у 
настольных компьютеров и планшетов, но производительностью хуже, чем у
телефонов было довольно сложно подобрать универсальный набор правил.

Мы используем данные user-agent для определения мобильных устройств и размер
окна для вычленения из них планшетов (645px и выше). В принципе каждый режим
может отображать все разрешения потому, что верстка основана на media queries
или относительное позиционирование (в процентах) с помощью JavaScript.

Так как в нашем случае дизайн не привязан к жёсткой сетке и контент очень
меняется от модуля к модулю, то сценарии и контрольные точки (breakpoints) сильно
зависят от специфического поведения конкретных элементов. Неоднократно случалось
так, что после того, как всё было идеально завёрстано с помощью миксинов sass и
media-queries нам необходимо было добавить эффект, привязанный к положению 
курсора или динамических объектов, и приходилось всё переписывать на JavaScript.

Кроме этого мы добавляем класс с текущим режимом в родительском тэге для
использования в стилях (пример в SCSS):

    .loc-hobbit-logo {
    
        // Значения по умолчанию.
    
        .desktop & {
            // Изменения только для режима «настольный».
        }
    
        .tablet &, .mobile & {
            
            // Обычно здесь другие ресурсы для планшетов и мобильных.
                @media screen and (max-height: 760px), (max-width: 760px) {
                // Специфические стили для этих контрольных точек.
            }
                @media screen and (max-height: 570px), (max-width: 400px) {
                // Специфические стили для этих контрольных точек.
            }
        }
    }
        

Мы поддерживаем все размеры экрана до 360x320, что оказалось довольно непростым
при создании этого сайта. Для компьютеров у нас предусмотрен минимальный размер,
после которого мы начинаем показывать полосы прокрутки, так как хотим, чтобы
по возможности пользователи просматривали сайт в большем разрешении. Для
мобильных разрешена и ландшафтная, и портретная ориентация, кроме интерактивных
мест, где пользователей просят повернуть устройство и просматривать в 
ландшафтной ориентации. Основной причиной этого явилось мнение о том, что в
портретном режиме сайт не вызывает такого сильного эффекта. В любом случае сайт 
хорошо адаптирован под любой размер экрана, поэтому мы оставили эту возможность.


> NOTE: **События DeviceOrientation** Вёрстка контента управляется контрольными
точками и CSS, но также нам нужно знать, когда происходит изменения ориентации
устройства в JavaScript, чтобы приостанавливать игры и анимации, и сохранять
при этом правильное состояние. Оказывается, что нельзя так уж полагаться на
значение `window.orientation`, потому что оно не стандартизовано и неодинаково
для разных устройств. Вместо этого лучше следить за событием и смотреть на
`window.innerWidth` и `window.innerHeight`, чтобы определить ориентацию.*

Хочется напомнить, что не стоит смешивать вёрстку с определением возможностей
вроде способа ввода, ориентации устройства, сенсоров и т.д. Всё это
должно быть в разных режимах и работать в них. Например, поддержка и мыши, и 
тач-событий. Также поддержка ретина-дисплеев для улучшения качества (но в
основном, для улучшения производительности — иногда производительность важнее
качества). Так, canvas-элементы генерируются в половину разрешения на
ретина-дисплеях, иначе пришлось бы рендерить в четыре раза больше пикселей.

Можно легко испытать все размеры прямо в браузере [эмулируя][4] устройство в 
Chrome DevTools. При переключении режима между мобильным, планшетом и настольным
компьютером нужно перезагружать сайт для получения правильных зависимостей и 
настроек.

Мы часто пользовались этим инструментом во время разработке, особенно в Chrome
Canary, в котором он предлагает улучшенные возможности и множество предустановок.
Это хороший способ проверить дизайн. При этом мы всё тестировали сайт на реальных
устройствах. В первую очередь потому, что сайт рассчитан на полноэкранный режим.
Страницы с вертикальной прокруткой скрывают браузерный скролл в большинстве
случаев (разве что в Safari на iOS7 с этим проблемы сейчас), и надо было всё
уместить независимо от этого. Мы использовали одну из предустановок в эмуляторе
и изменяли размер экрана, чтобы симулировать потерю доступного места.
Тестирование на реальных устройствах также очень важно для отслеживания затрат
памяти и измерения производительности.


## Управление состоянием

Сразу за [посадочной страницей][2] мы попадаем на карту Средиземья. Вы обратили
внимание на то, что адрес поменялся? Сайт — это одностраничное приложение,
которое использует [History API][5] для [управления путями][6].

Каждая секция сайта — это отдельный объект, наследующий шаблон с основным
функционалом, включая DOM-элементы, переходы, загрузку ресурсов, сбор мусора
и т.д. По ходу продвижения по сайту разные секции инициализируются, добавляя и
удаляя элементы и ресурсы для конкретного раздела.

Так как пользователь может нажать кнопку «Назад» в браузере или передвигаться с
помощью меню, то нужно следить и за очищением старых элементов. Таймауты и
анимации должны быть остановлены и отменены, иначе это может вызвать
нежелательные последствия, ошибки и утечки памяти. Это не всегда является
простой задачей, особенно накануне дедлайна, когда нужно, чтобы всё заработало,
как можно скорее.

Однако достаточно просто отслеживать события. Хорошей практикой является
добавление функции очистки для каждого объекта. Важно не забывать про таймеры и
циклы анимаций. При использовании этих циклов, используйте эквивалент
`TweenMax.killTweensOf(foo)` или сохраняйте ссылки на них в переменных и
останавливайте вызов колбэков. Удаляйте временно созданные элементы DOM. Полезно
часто обращаться к инструменту профилирования для контроля потребления памяти и
утечек.


## Места съёмки

Для того, чтобы показать места съёмки и персонажей Средиземья во всей красе,
мы построили модульную систему для картинок и текстов, которые можно двигать
мышкой или пальцами на тач-устройствах по горизонтали. Полоса прокрутки не
отображается, так как нам нужна была возможность двигать разные объекты с разной
скоростью, как, например, в «рядах» картинок, когда можно остановить движение до
того, как клип закончился.
 
> NOTE Полоса прокрутки предполагает определённый тип поведения. Если сайт неожиданно
перехватывает управление этим элементом, то это может оставить неприятное 
впечатление у пользователя.
*Einar Öberg*

![][7]

*Таймлайн для [Thranduil's Hall][8]*


### Таймлайны

В начале разработки мы не знали, какой именно контент будет в каждом модуле. Но
мы знали наверняка, что нам нужно будет подготовить некий шаблон для отображения
разных типов медиа-файлов и информации в виде горизонтального таймлайна, что
позволит нам показать шесть разных историй без перестраивания всей системы
каждый раз. Для этого мы создали контроллер таймлайнов, чтобы управлять 
«перетаскиванием» этих модулей с учётом настроек и особенностей каждого из них.


### Модули и компоненты поведения

Мы создали отдельные модули для «рядов» картинок, статичных картинок, сцен с
параллакс-эффектом, сцен с изменением фокуса и текста. Сцены с
параллакс-эффектом имеют непрозрачный фон и некоторое количество слоёв, 
позиционирование которых связано с продвижением пользователя по странице. Сцены
с изменением фокуса — это по сути подвид предыдущего модуля с тем отличием, что
мы используем две картинки для каждого слоя, которые плавно исчезают, симулируя
изменение фокуса. Мы пытались использовать CSS-фильтр blur, но он всё ещё
слишком требователен к ресурсам устройства, поэтому стоит подождать официального
выхода CSS-шейдеров. Текст в текстовых модулях можно «таскать» с помощью плагина
[Draggable][9] от TweenMax. Кроме этого можно использовать колесо мыши или свайп
двумя пальцами, чтобы прокручивать текст по вертикали. Обратите внимание на
плагин [throw-props][10], который добавляет эффект «броска» при окончании свайпа.
У модулей есть разные сценарии поведения, которые подключаются как наборы
компонентов. Они привязываются к определённым селекторам и имеют собственные
настройки. Для движения элементов используется `translate`, `scale` для
масштабирования, «горячие» точки для всплывающих подсказок, отладочные данные
для визуального тестирования,  слой для отображения названия перед запуском,
слой для эффектов и некоторые другие вещи. Всё это добавляется в структуру
документа и управляется элементом-родителем внутри модуля. С таким подходом мы
можем показывать разные истории с помощью всего лишь [файла настроек][11], 
которые определяет, какие ресурсы загружать и настраивает разные типы модулей и
компонентов.


### «Ряды» картинок

Самым сложным с точки зрения производительности и объёма загружаемых
данных оказалась разработка модуля для «рядов» картинок. По этой теме уже немало
[написано][12]. На мобильных и планшетах мы заменяем их статичным изображением.
Это всё ещё слишком большой объём данных для обработки и хранения в памяти, если
мы хотим добиться высокого качества на мобильных устройствах. Мы пробовали
несколько альтернативных подходов. Сначала мы пробовали использование фоновой
картинки и спрайтов, но это привело к проблемам с памятью и задержкой, когда
процессору нужно было переключаться между разными спрайтами. Потом мы пробовали
заменять сами элементы `img`, но это тоже было очень медленно. Отрисовка кадра из
спрайта с помощью `canvas` было наиболее быстрым, и мы решили использовать этот
способ. Для того, чтобы сэкономить время для расчётов каждого кадра, изображение
предварительно обрабатывается во временном `canvas`-е и сохраняется с помощью
`putImageData()` в специальный массив, уже готовое к использованию. После этого
оригинальный спрайт может быть удалён из памяти, так как мы храним только
минимально необходимую информацию. Возможно, необработанные изображения занимали
бы меньше памяти, но при нашем подходе производительность выше. Кадры довольно
маленькие, всего 640x400, но это можно увидеть только при прокрутке. Когда 
анимация останавливается, картинка большего разрешения сразу появляется поверх.

    var canvas = document.createElement('canvas');
    canvas.width = imageWidth;
    canvas.height = imageHeight;

    var ctx = canvas.getContext('2d');
    ctx.drawImage(sheet, 0, 0);

    var tilesX = imageWidth / tileWidth;
    var tilesY = imageHeight / tileHeight;

    var canvasPaste = canvas.cloneNode(false);
    canvasPaste.width = tileWidth;
    canvasPaste.height = tileHeight;

    var i, j, canvasPasteTemp, imgData, 
    var currentIndex = 0;
    var startIndex = index * 16;
    for (i = 0; i < tilesY; i++) {
      for (j = 0; j < tilesX; j++) {
        // Store the image data of each tile in the array.
        canvasPasteTemp = canvasPaste.cloneNode(false);
        imgData = ctx.getImageData(j * tileWidth, i * tileHeight, tileWidth, tileHeight);
        canvasPasteTemp.getContext('2d').putImageData(imgData, 0, 0);

        list[ startIndex + currentIndex ] = imgData;

        currentIndex++;
      }
    }

Спрайты создаются с помощью [Imagemagick][13]. Здесь есть простой
[пример на GitHub][14], который показывает, как создать спрайт из
картинок в папке.
        
### Анимация модулей

Когда модули размещены в таймлайне, в специальном скрытом блоке создаётся
их условное представление, которое связано с позицией и размерами модулей.
Мы сделали и визуальное отображение для этого инструмента, чтобы легче 
проводить отладку. На работающем проекте он, конечно, скрыт и в нём обновляются
только размеры и положение элементов. Из-за того, что некоторые 
модули заполняют экран полностью, а некоторые имеют свои фиксированные
соотношения сторон, правильно размещать и масштабировать все элементы
так, чтобы они оставались видимыми и не слишком обрезаны, было довольно
непростой задачей. Каждый модуль имеет два индикатора прогресса — первый для
видимой на экране части и второй для измерения длительности самого модуля. При
создании движения в параллакс-сцене часто бывает сложно рассчитать начальную и
конечную позицию объектов с тем, чтобы синхронизировать с позицией, когда они
в зоне видимости. Гораздо проще работать, когда точно знаешь, что сейчас
происходит с модулем — находится ли он на экране, на каком этапе его
внутренняя анимация и когда он исчезает. 

<iframe
    src="http://demo.northkingdom.com/hobbit/timeline/"
    frameborder="0" width="100%" height="440"></iframe>

Поверх контента каждого модуля есть слой с чёрной заливкой, который становится
полностью прозрачным, когда модуль в центральной позиции и видим на экране. Так
пользователю гораздо легче сосредоточиться на содержании.


### Производительность

Прогресс от функционального прототипа к плавно работающей релизной версии 
означает переход от угадывания к уверенности в том, что происходит в браузере.
Это тот момент, когда инструмент DevTools в Chrome становится лучшим другом.

Мы провели довольно много времени, оптимизируя сайт. Использование аппаратного
ускорения — один из самых важных способов обеспечить плавные переходы и
анимации. Кроме этого, нужно охотиться за [цветными колонками][15] и красными
прямоугольниками в DevTools. На эту тему достаточно материала, и вам следует
прочитать его [целиком][16]. Устранение «проскакивающих» кадров в анимации 
мгновенно приносит облегчение, но при их повторном появлении это так же
неприятно. И они будут снова появляться. Это процесс, растянутый во времени и
требующий нескольких итераций.

> NOTE Следите за панелью `layers` (только в Chrome Canary) и `paint rectangles`
в DevTools. Например, если дочерние элементы нужно обновлять на каждом кадре,
стоит проверить, не будет ли быстрее изменять порядок элементов, чтобы 
отрисовывать, как можно меньше.

Я люблю TweenMax от Greensock для зацикливания свойств, трансформаций и CSS.
Визуализируйте структуру при добавлении новых слоёв. Имейте в виду, что
существующие трансформации могут быть перезаписаны новыми. Свойство
`translateZ(0)`, которое приводит к принудительному использованию аппаратного
ускорения для CSS, заменяется на двумерную матрицу, если нужно зациклить только
двумерные (2D) значения. Поэтому если для этого слоя всё же нужно использовать
аппаратное ускорение, можно установить значение `force3D:true` в цикле для
превращение двумерной матрицы в трёхмерную. Легко упустить эти мелочи в
стилях, когда смешиваешь CSS и JavaScript при анимации.

Не используйте принудительное ускорение, когда это не нужно. Память
графического процессора может быстро закончиться, что может вызвать
нежелательные последствия, если вы хотите применять ускорение для многих
контейнеров, особенно это актуально для iOS, где память имеет более жёсткие
ограничения. Загрузка менее «тяжёлых» ресурсов и их масштабирование с помощью
CSS, а также отключение некоторых эффектов для мобильных привело к отличным
улучшениям в работе.

[Утечки памяти][17] явились ещё одним полем, где нам пришлось существенно
улучшить свои навыки. При навигации между разными WebGL-сценами создаётся 
много разнообразных объектов, материалов, текстур и геометрических данных.
Если всё это вовремя не очищать, то, скорее всего, при следующем переходе память
закончится и это приведёт к «падению» устройства.

![][18]

*Выход из радела с плохо работающей функцией очистки.*

![][19]

*Намного лучше!*

Для нахождения утечек мы использовали профилирование в DevTools и сохраняли
отчёты. Легче приходится, когда есть конкретные объекты, которые легко
отследить, например, трёхмерная геометрия или определённая библиотека. В
примере, приведённом выше, оказалось, что трёхмерная сцена и массив с данными
всё ещё находились в памяти. Если всё же возникают сложности с поиском нужного
объекта, рекомендуем прибегнуть к любопытной функции [retaining paths][20].
Достаточно нажать на интересующий элемент в отчёте профайлера и можно получить
информацию о нём в панели снизу. Хорошая структура, построенная на небольших
объектах, помогает при поиске этих связей.

![][21]

*Сцена была вызвана EffectComposer.*

В целом, стоит подумать дважды прежде, чем манипулировать элементами в
документе. Если вы всё-таки делаете это, не забывайте об эффективности. По
возможности не двигайте элементы во время игрового цикла. Если нужно найти
некоторый элемент используйте самый короткий путь, сохраняя ссылки к главным
контейнерам и ищите внутри ближайшего родительского блока.

В ситуациях, когда нужно узнать размеры вновь добавленных элементов, делайте
это с небольшой задержкой, если иначе появляются баги. Также можно убедиться,
[разметка инициализирована][22]. Иногда браузер собирает изменения для стилей в
«пакет» и не применяет их до следующей инициализации. Это может привести к
серьёзным проблемам, но это сделано неспроста, поэтому стоит понять природу
такого поведения и научиться работать с ним.


### Полноэкранный режим

Некоторые модули позволяют перевести сайт в полноэкранный режим с помощью
Fullscreen API. Но в мобильных браузерах существует ещё один порог
ограничений для этой возможности. Safari на iOS раньше позволял управлять
переходом в полноэкранный режим, но сейчас это недоступно, поэтому стоит
подготовить свой дизайн для работы в обычном режиме для страниц без прокрутки.
Мы полагаем, что стоит ожидать изменений в будущих обновлениях, так как запрет
использования этой технологии нарушил работу многих веб-приложений.


## Ресурсы

![][23]

*Анимированные инструкции для экспериментов.*

На сайте используются разные типы ресурсов: изображения (PNG и JPEG), SVG
(в контент и в фоне), спрайты (PNG), нестандартные иконочные шрифты и анимации
из Adobe Edge. Мы используем PNG для основных ресурсов и анимаций (в виде 
спрайтов), когда элемент не может быть реализован векторно, но для всех других
случаев мы стараемся использовать SVG.

Векторный формат означает отсутствие потерь качества, даже при масштабировании.
Один файл для всех типов устройств.

*   Маленький размер файл.
*   Каждая часть может быть анимирована независимо (особенно удобно для
сложных анимаций). Как пример можно привести подзаголовок в логотипе Хоббита
(*the desolation of Smaug*) при масштабировании.
*   Может использоваться и как тэг SVG, и как фоновое изображение без каких бы
бы то ни было дополнительных подгрузок (загружается вместе с остальной частью
страницы).

Иконочные шрифты обладают теми же преимуществами, что и SVG, когда речь идёт о
масштабировании и используется вместо SVG для небольших элементов, для которых 
нужно изменять только цвет (например, состояние кнопок — активна, ховер и
т.д.). Иконки также очень удобны для повторного использования, достаточно
изменить CSS свойство `content`.


## Анимации

В некоторых случаев анимация SVG-элементов с помощью скриптов может быть
довольно трудозатратным, особенно, если анимация меняется во время правок
дизайна. Для улучшения взаимодействия дизайнеров и разработчиков мы иногда
используем Adobe Edge (например, для инструкций перед играми). Процесс работы
над анимацией очень похож на работу с Flash и это помогло нашей команде, но всё
ещё есть недочёты, что связано с внедрением Edge-анимаций в загрузку наших
ресурсов, так как Adobe использует собственные загрузчики и логику внедрения.

Я думаю, что нам предстоит ещё долгий путь по оттачиванию процесса работы с
ресурсами и анимациями, сделанными «вручную». Мы с интересом наблюдаем за
развитием инструментов вроде Edge. С удовольствием выслушаем ваши предложения
на эту тему в комментариях.


## Выводы

Сейчас, когда весь проект запущен и я смотрю на конечный результат, могу
сказать, что я довольно впечатлён уровнем современных мобильных браузеров. В 
начале работы над этим сайтом наши ожидания насчёт того, насколько плавно и 
красиво всё будет работать, были намного ниже. Это был отличный опыт для всех
нас, и всё время, потраченное на разработку и тестирование (особенно на него)
улучшили наше понимание того, как работают современные браузеры. И, конечно,
это сократит время на разработку подобных проектов в будущем, путь от 
угадывания к уверенности.


[1]: http://www.html5rocks.com/en/tutorials/casestudies/hobbit/
[2]: http://middle-earth.thehobbit.com/
[3]: img/eagles.png

[4]: https://developers.google.com/chrome-developer-tools/docs/mobile-emulation
[5]: http://diveintohtml5.info/history.html
[6]: http://visionmedia.github.io/page.js/
[7]: img/thranduils-hall.jpg
[8]: http://middle-earth.thehobbit.com/thranduils-hall
[9]: http://www.greensock.com/draggable/
[10]: http://www.greensock.com/throwprops/
[11]: https://gist.github.com/inear/7626665
[12]: http://awardwinningfjords.com/2012/03/08/image-sequences.html
[13]: http://www.imagemagick.org/script/index.php
[14]: https://gist.github.com/inear/7616849

[15]: https://developers.google.com/chrome-developer-tools/docs/tips-and-tricks#timeline-frames-mode
[16]: http://jankfree.org/
[17]: http://www.html5rocks.com/en/tutorials/memory/effectivemanagement/
[18]: img/failing-dispose.png
[19]: img/much-better.png

[20]: https://developers.google.com/chrome-developer-tools/docs/heap-profiling?hl=sv&csw=1#views_paths
[21]: img/effectcompositor.png

[22]: http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/#toc-animating-layout-properties
[23]: img/instructions.jpg
[24]: img/einaroberg.png